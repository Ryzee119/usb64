/* MIT License
 * 
 * Copyright (c) [2020] [Ryan Wendland]
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include "printf.h"
#include "n64_mempak.h"
#include "n64_virtualpak.h"
#include "n64_settings.h"
#include "n64_transferpak_gbcarts.h"
#include "n64_controller.h"
#include "n64_wrapper.h"

#define HEADING MENU_LINE1
#define SUBHEADING MENU_LINE2

#define MENU_TPAK MENU_LINE4
#define MENU_CONTROLLER_SETTINGS MENU_LINE5

#define CHANGE_CONTROLLER MENU_LINE15
#define MENU_MAIN MENU_LINE16
#define RETURN MENU_MAIN

static uint8_t controller_page = 0;
static uint8_t current_menu = MENU_MAIN;
static char buff[64];
static uint8_t num_roms = 0;
static char *gbrom_filenames[32] = {NULL}; //Gameboy ROM List
static char *gbrom_titlenames[32] = {NULL}; //Gameboy ROM List

//First 32 bytes of mempak. First byte must be 0x81. This small section is in RAM as the console writes to it
uint8_t n64_virtualpak_scratch[0x20] = {
    0x81, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F};

//First 0x300 bytes of mempak. I took this from a mempak I generated on my n64.
const uint8_t n64_virtualpak_header[0x300] = {
    0x81, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
    0xFF, 0xFF, 0xFF, 0xFF, 0x05, 0x1A, 0x5F, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0x66, 0x25, 0x99, 0xCD,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0xFF, 0xFF, 0x05, 0x1A, 0x5F, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0x66, 0x25, 0x99, 0xCD,
    0xFF, 0xFF, 0xFF, 0xFF, 0x05, 0x1A, 0x5F, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0x66, 0x25, 0x99, 0xCD,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0xFF, 0xFF, 0x05, 0x1A, 0x5F, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0x66, 0x25, 0x99, 0xCD,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x51, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
    0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
    0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03,
    0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03,
    0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03,
    0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03,
    0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03,
    0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03,
    0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03,
    0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03,
    0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03,
    0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03,
    0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03,
    0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03,
    0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03,
    0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03,
    0x00, 0x51, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
    0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
    0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03,
    0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03,
    0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03,
    0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03,
    0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03,
    0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03,
    0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03,
    0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03,
    0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03,
    0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03,
    0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03,
    0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03,
    0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03,
    0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03};

//This is the notesTable located at address 0x300 to 0x500 in the mempack address space.
//This initialises the title blocks as all blank titles using 1 page each.
/* 0x4E = N (Media Type Cartridge)
 * 0x41 = R    Game Name Code of sorts. ZL = Zelda, PO = Pokemon Snap.
 * 0x43 = Y RY=Ryan :P
 * 0x45 = E Region "North America"
 * 0x35 = 5 Publisher Code
 * 0x48 = H Publisher Code
 * 0x00 = Always 0x00
 * 0x05 = Between 5 and 127, Page Index
 * 0x02 = ?
 * 0x03 = ?
 */
uint8_t n64_virtualpak_note_table[0x200] = {
    0x4E, 0x41, 0x43, 0x45, 0x35, 0x48, 0x00, 0x05, 0x02, 0x03, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00,
    0x1A, 0x2B, 0x26, 0x32, 0x26, 0x1E, 0x27, 0x1A, 0x22, 0x2B, 0x1C, 0x28, 0x26, 0x1B, 0x1A, 0x2D,
    0x4E, 0x41, 0x43, 0x45, 0x35, 0x48, 0x00, 0x06, 0x02, 0x03, 0x00, 0x00, 0x1B, 0x00, 0x00, 0x00,
    0x1A, 0x2B, 0x26, 0x32, 0x26, 0x1E, 0x27, 0x1A, 0x22, 0x2B, 0x1C, 0x28, 0x26, 0x1B, 0x1A, 0x2D,
    0x4E, 0x41, 0x43, 0x45, 0x35, 0x48, 0x00, 0x07, 0x02, 0x03, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00,
    0x1A, 0x2B, 0x26, 0x32, 0x26, 0x1E, 0x27, 0x1A, 0x22, 0x2B, 0x1C, 0x28, 0x26, 0x1B, 0x1A, 0x2D,
    0x4E, 0x41, 0x43, 0x45, 0x35, 0x48, 0x00, 0x08, 0x02, 0x03, 0x00, 0x00, 0x1D, 0x00, 0x00, 0x00,
    0x1A, 0x2B, 0x26, 0x32, 0x26, 0x1E, 0x27, 0x1A, 0x22, 0x2B, 0x1C, 0x28, 0x26, 0x1B, 0x1A, 0x2D,
    0x4E, 0x41, 0x43, 0x45, 0x35, 0x48, 0x00, 0x09, 0x02, 0x03, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00,
    0x1A, 0x2B, 0x26, 0x32, 0x26, 0x1E, 0x27, 0x1A, 0x22, 0x2B, 0x1C, 0x28, 0x26, 0x1B, 0x1A, 0x2D,
    0x4E, 0x41, 0x43, 0x45, 0x35, 0x48, 0x00, 0x0A, 0x02, 0x03, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00,
    0x1A, 0x2B, 0x26, 0x32, 0x26, 0x1E, 0x27, 0x1A, 0x22, 0x2B, 0x1C, 0x28, 0x26, 0x1B, 0x1A, 0x2D,
    0x4E, 0x41, 0x43, 0x45, 0x35, 0x48, 0x00, 0x0B, 0x02, 0x03, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
    0x1A, 0x2B, 0x26, 0x32, 0x26, 0x1E, 0x27, 0x1A, 0x22, 0x2B, 0x1C, 0x28, 0x26, 0x1B, 0x1A, 0x2D,
    0x4E, 0x41, 0x43, 0x45, 0x35, 0x48, 0x00, 0x0C, 0x02, 0x03, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00,
    0x1A, 0x2B, 0x26, 0x32, 0x26, 0x1E, 0x27, 0x1A, 0x22, 0x2B, 0x1C, 0x28, 0x26, 0x1B, 0x1A, 0x2D,
    0x4E, 0x41, 0x43, 0x45, 0x35, 0x48, 0x00, 0x0D, 0x02, 0x03, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00,
    0x1A, 0x2B, 0x26, 0x32, 0x26, 0x1E, 0x27, 0x1A, 0x22, 0x2B, 0x1C, 0x28, 0x26, 0x1B, 0x1A, 0x2D,
    0x4E, 0x41, 0x43, 0x45, 0x35, 0x48, 0x00, 0x0E, 0x02, 0x03, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00,
    0x1A, 0x2B, 0x26, 0x32, 0x26, 0x1E, 0x27, 0x1A, 0x22, 0x2B, 0x1C, 0x28, 0x26, 0x1B, 0x1A, 0x2D,
    0x4E, 0x41, 0x43, 0x45, 0x35, 0x48, 0x00, 0x0F, 0x02, 0x03, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00,
    0x1A, 0x2B, 0x26, 0x32, 0x26, 0x1E, 0x27, 0x1A, 0x22, 0x2B, 0x1C, 0x28, 0x26, 0x1B, 0x1A, 0x2D,
    0x4E, 0x41, 0x43, 0x45, 0x35, 0x48, 0x00, 0x10, 0x02, 0x03, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00,
    0x1A, 0x2B, 0x26, 0x32, 0x26, 0x1E, 0x27, 0x1A, 0x22, 0x2B, 0x1C, 0x28, 0x26, 0x1B, 0x1A, 0x2D,
    0x4E, 0x41, 0x43, 0x45, 0x35, 0x48, 0x00, 0x11, 0x02, 0x01, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00,
    0x1A, 0x2B, 0x26, 0x32, 0x26, 0x1E, 0x27, 0x1A, 0x22, 0x2B, 0x1C, 0x28, 0x26, 0x1B, 0x1A, 0x2D,
    0x4E, 0x41, 0x43, 0x45, 0x35, 0x48, 0x00, 0x12, 0x02, 0x01, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00,
    0x1A, 0x2B, 0x26, 0x32, 0x26, 0x1E, 0x27, 0x1A, 0x22, 0x2B, 0x1C, 0x28, 0x26, 0x1B, 0x1A, 0x2D,
    0x4E, 0x41, 0x43, 0x45, 0x35, 0x48, 0x00, 0x13, 0x02, 0x01, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00,
    0x1A, 0x2B, 0x26, 0x32, 0x26, 0x1E, 0x27, 0x1A, 0x22, 0x2B, 0x1C, 0x28, 0x26, 0x1B, 0x1A, 0x2D,
    0x4E, 0x41, 0x43, 0x45, 0x35, 0x48, 0x00, 0x14, 0x02, 0x01, 0x00, 0x00, 0x29, 0x00, 0x00, 0x00,
    0x1A, 0x2B, 0x26, 0x32, 0x26, 0x1E, 0x27, 0x1A, 0x22, 0x2B, 0x1C, 0x28, 0x26, 0x1B, 0x1A, 0x2D};

//msg is a null terminated ascii string
//line is what line to write the string on in the mempak menu. 0-15
//ext, There is a 4 character long extension in the mempack menu for
//each line, Set this to one to write to that instead.
static void n64_virtualpak_write_string(char *msg, uint8_t line, uint8_t ext)
{
    static const uint8_t MEMPACK_CHARMAP[] =
    {
        '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', 
        ' ' , '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' ,
        'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' ,
        'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' ,
        '!' , '"' , '#' , '\'', '*' , '+' , ',' , '-' , '.' , '/' , ':' , '=' , '?' , '@'
    };

    uint8_t max_len;
    uint8_t len = 0xFF;

    (ext == 1) ? (max_len = 4) : (max_len = 16);

    for (uint8_t i = 0; i < max_len; i++)
    {
        uint8_t n64char = 0;

        //If string terminator, fix length
        if (msg[i] == '\0')
            len = i;

        //Force upper case
        if (msg[i] > 96)
            msg[i] -= 32;

        //Handle some unique cases
        if (msg[i] == '_')
            msg[i] = '-'; //replace _ with -

        //Find a match in the CHARMAP
        for (uint8_t j = 0; j < sizeof(MEMPACK_CHARMAP); j++)
        {
            if (msg[i] == MEMPACK_CHARMAP[j])
                n64char = j;
        }

        //Pad with spaces if past end
        if (i > len)
            n64char = 1;

        //Replace unknown character with a space.
        if (n64char == 0)
            n64char = 1;

        //Write to char to the note table
        if (ext)
        {
            n64_virtualpak_note_table[(32 * line) + 12 + i] = n64char;
        }
        else
        {
            n64_virtualpak_note_table[(32 * line) + 16 + i] = n64char;
        }
    }
}

void n64_virtualpak_init(n64_mempack *vpak)
{
    char alpha[2] = {'A', '\0'};
    vpak->virtual_is_active = 1;
    vpak->virtual_selected_row = -1;
    vpak->virtual_update_req = 1;
    for (uint8_t i = 0; i < 16; i++)
    {
        n64_virtualpak_write_string("-",   i, MENU_NAME_FIELD);
        n64_virtualpak_write_string(alpha, i, MENU_EXT_FIELD);
        alpha[0]++;
    }
    n64_virtualpak_write_string("N360 BY RYZEE119", HEADING,  MENU_NAME_FIELD);
    n64_virtualpak_write_string("CHANGE CONT",   CHANGE_CONTROLLER, MENU_NAME_FIELD);
    n64_virtualpak_write_string("RETURN",           RETURN, MENU_NAME_FIELD);

    /* Scan FATFS flash for ROMS and populate an array to list them */

    //Clear up any previous memory allocations
    for(int i = 0 ; i < 32; i++){
        if (gbrom_filenames[i] !=NULL)
        {
            free(gbrom_filenames[i]);
        }
            
        if (gbrom_titlenames[i] !=NULL)
        {
            free(gbrom_titlenames[i]);
        }
        gbrom_filenames[i] = NULL;
        gbrom_titlenames[i] = NULL;
    }

    num_roms = n64hal_scan_flash_gbroms(gbrom_filenames);
    for (int i = 0; i < num_roms; i++)
    {
        uint8_t gb_header[0x100];
        gameboycart gb_cart;
        //Copy the FATFS filename into an array
        strcpy((char*)gb_cart.filename, gbrom_filenames[i]);
        if (n64hal_rom_read(&gb_cart, 0x100, gb_header, sizeof(gb_header)))
        {
            gb_initGameBoyCart(&gb_cart, gb_header, gbrom_filenames[i]);
            //Copy the gb cart title (from the rom header into an array)
            gbrom_titlenames[i] = (char*)malloc(strlen((char*)gb_cart.title) + 1);
            strcpy(gbrom_titlenames[i], (char*)gb_cart.title);
        }
    }
}

void n64_virtualpak_read32(uint16_t address, uint8_t *rx_buff)
{
    if (address < 0x20)
    {
        memcpy(rx_buff, &n64_virtualpak_scratch[address], 32);
    }
    else if (address < 0x300)
    {
        memcpy(rx_buff, &n64_virtualpak_header[address], 32);
    }
    else if (address < 0x500)
    {
        memcpy(rx_buff, &n64_virtualpak_note_table[address - 0x300], 32);
    }
    else
    {
        memset(rx_buff, 0x00, 32);
    }
}

void n64_virtualpak_write32(uint16_t address, uint8_t *tx_buff)
{
    //If address is in scratch space, write it.
    //Ignore other writes. Dont actually want the N64 to write over stuff
    //If this scratch space doesnt get written, n64 assumes corrupt mempak.
    if (address < 0x20)
    {
        memcpy(&n64_virtualpak_scratch[address], tx_buff, 32);
    }
}

void n64_virtualpak_update(n64_mempack *vpak)
{
    n64_settings* settings = n64_settings_get();

    //PREP VIRTUAL PAK FOR UPDATE
    char alpha[2] = {'B', '\0'};
    for (uint8_t i = 1; i < 14; i++)
    {
        n64_virtualpak_write_string("-", i, MENU_NAME_FIELD);
        n64_virtualpak_write_string(alpha, i, MENU_EXT_FIELD);
        alpha[0]++;
    }

    //You selected a row, what row?
    switch(vpak->virtual_selected_row){
        case RETURN:
        case HEADING:
            current_menu = MENU_MAIN;
            break;
        case MENU_TPAK:
            current_menu = MENU_TPAK;
            break;
        case MENU_CONTROLLER_SETTINGS:
            current_menu = MENU_CONTROLLER_SETTINGS;
            break;
        case CHANGE_CONTROLLER:
        case SUBHEADING:
            controller_page++;
            if(controller_page >= MAX_CONTROLLERS)
                controller_page = 0;
            break;
    }

    //Print the required menu
    if (current_menu == MENU_MAIN)
    {
        switch (vpak->virtual_selected_row)
        {
        case MENU_TPAK:
            current_menu = MENU_TPAK;
            break;
        case MENU_CONTROLLER_SETTINGS:
            current_menu = MENU_CONTROLLER_SETTINGS;
            break;
        default:
            sprintf(buff,"CONTROLLER %u", controller_page + 1);
            n64_virtualpak_write_string(buff,               SUBHEADING, MENU_NAME_FIELD);
            n64_virtualpak_write_string("________________", SUBHEADING + 1, MENU_NAME_FIELD);
            n64_virtualpak_write_string("TPAK SETTINGS",    MENU_TPAK, MENU_NAME_FIELD);
            n64_virtualpak_write_string("CONT SETTINGS",    MENU_CONTROLLER_SETTINGS, MENU_NAME_FIELD);
            break;
        }
    }
    else if (current_menu == MENU_TPAK)
    {
        sprintf(buff,"CONTROLLER %u", controller_page + 1);
        n64_virtualpak_write_string(buff,               SUBHEADING, MENU_NAME_FIELD);
        n64_virtualpak_write_string("________________", SUBHEADING + 1, MENU_NAME_FIELD);
        n64_virtualpak_write_string("TPAK SETTINGS",    SUBHEADING + 2, MENU_NAME_FIELD);

        for (int i = 0; i < num_roms; i++)
        {
            n64_virtualpak_write_string(gbrom_titlenames[i], SUBHEADING + 2 + i, MENU_NAME_FIELD);
        }

        //List ROMS with the header rom name
        //Put * next to current default
        //Write actual filename to settings.default_tpak_rom[controller_page]
        //Put * next to new default
    }
    else if (current_menu == MENU_CONTROLLER_SETTINGS)
    {
        sprintf(buff,"CONTROLLER %u", controller_page + 1);
        n64_virtualpak_write_string(buff,               SUBHEADING, MENU_NAME_FIELD);
        n64_virtualpak_write_string("________________", SUBHEADING + 1, MENU_NAME_FIELD);
        n64_virtualpak_write_string("CONT SETTINGS",    SUBHEADING + 2, MENU_NAME_FIELD);
    }
    vpak->virtual_update_req = 0;
    vpak->virtual_selected_row = -1;
}
